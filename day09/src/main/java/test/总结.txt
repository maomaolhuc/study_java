多态
问题
成员变量相同时
	编译: 看父类是否存在这个成员变量,不存在编译失败
	运行: 父类的
方法:
	编译: 看父类是否存在这个方法,不存在编译失败
	运行: 子类的方法
静态方法:
	编译: 看父类是否存在这个方法,不存在编译失败
	运行: 父类的方法 静态和对象没关系 类去绑定的
多态引用变量的有两个类型 一个是编译的类型 一个是运行的类型 编译时的类型有声明变量的类型决定
如果编译时的类型和运行的类型不一致的时候 就是出现多态
成员变量和静态方法编译运行看左边
方法编译看左边 运行看右边

前提:
	有继承或实现 重写过程
	父类型引用指向子类型
实现:
	具体的类
	抽象的类
	接口
好处: 提高了扩展性  (向上转型) 调用的时候 只会调用覆盖父类的部分 编译的时候是要看父类有没有 
             修饰词 父类 缺省 public protected 
坏处: 不能去调用自己的特有方法  (向下转型 变成子类去调用自己的方法)
向下转型:有风险
	instanceof去检测是不是子类的实例  因为编译的时候无法检测出来错误
	F f = new Zi();
	if(f instanceof Zi){
	   Zi z = (Zi)f;
	}

	

	






