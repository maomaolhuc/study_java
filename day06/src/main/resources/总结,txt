面向对象
	事物其实就是有很多的属性和行为构成的 
	描述一个事物的时候其实就是在描述他的行为和属性 自定义的数据类型
	一个数据类型主要由几部分构成
		1. 类型本身有属性           
		2. 类型本身可以去操作
		3. 创建 通过变量去体现  int a
		4. 创建的实例可以去操作
		## 注意并不是所有的数据类型都有这些 有些只有操作 属性
 	挖掘机炒菜 把事物转变为代码的过程 体现的过程
 	
 	类的中的成员变量 存放在堆内存中 当对象被创建的时候就会赋予一个初始化的值
 	int = 0 float = 0.0 double = 0.0 boolean = false char = '\u000' String = null;
 	
 	
 	区别一下成员变量和局部变量
 	1. 位置不同
 		成员变量在类中
 		局部变量在方法中语句中
 	2. 在内存中位置不同
 		成员变量在堆内存中
 		局部变量是在栈内存中
 	3. 生命周期不同
 		成员变量会随着对象的消失而消失
 		局部变量会随着方法的出栈(手枪弹夹)而消失
 	4. 初始化
 		成员变量在堆内存中 会有初始化值
 		局部变量是没有初始化值的,必须要有初始化值才可以使用
 		
  	通过对象.属性访问的问题
  		1. 可能会有一些错误的操作所以对属性进行了私有化
  		 私有化之后不能访问了 于是提供了一个方法 set get方法去获取设置属性的值
  		为什么要用一个方法呢? 那是因为方法中可以写语句 if 限制set get
  		
  		2.虽然通过了get set可以做到访问设置属性 但是频繁的操作函数其实也是一种开销
  		 能不能在创建对象的时候就进行属性的初始化呢? 可以的
  		
  		3. 构造函数
	  		  写法: 必须和类名一致 没有具体的返回值 
	  		 ###可不可以写return 可以
  		 	 
  		 	 ###没有写的时候 在编译的时候会自动创建一个无参数的构造函数
  		 	 ###写的时候就不会去创建这个无参数的构造函数了 因为可能会引起冲突
  		
 			 问题有了构造还要get set吗?
 			 要! 因为可能会对属性进行修改操作
 			 
 			构造函数可不可以private
 			可以的 
 			目的: 为了不去创建对象 隐藏  (封装)
 			
 			get set中this使用 为了区别参数的 this(指明当前的对象)
 			
 			
 			构造函数可以有多个 因为重载
 			
 			构造函数之间的相互调用
 			this(参数列表) 必须在第一行
 		构造函数和一般函数
 			1. 写法区别
 			2. 执行 创建对象的时候 传递的不同的参数列表 调用不同的构造函数
 			3. 构造只能执行一次  一般函数可以执行多次
 		
 		构造函数和成员变量的位置
 			成员变量书写的位置与执行的位置没关系 成员变量一定是在构造函数之前初始化的
 			如果构造函数先执行 在初始化 构造函数给的值还会存在嘛?不会
 		
 		
 		